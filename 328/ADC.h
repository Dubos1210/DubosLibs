/* Analog to Digital Converter Library for Atmel AVR v0.4
 *  ADC_init();     //Инициализация АЦП
 *  ADC_read(ADC0); //Измерение сигнала на входе ADC0
 */
 
#ifndef DUBOS_ADC
#define DUBOS_ADC
 
#define ADC0            0x00
#define ADC1            0x01
#define ADC2            0x02
#define ADC3            0x03
#define ADC4            0x04
#define ADC5            0x05
#define ADC_TEMPERATURE 0x08 
#define ADC_REFERENCE   0x0E
#define ADC_GND         0x0F  
 
/*******************************************
 * Функция	: инициализация АЦП
 *******************************************/
void ADC_init(void) {
	ADMUX = (1<<REFS1)|(1<<REFS0)|(0<<ADLAR)|(0<<MUX3)|(0<<MUX2)|(0<<MUX1)|(0<<MUX0);
	/*Биты REFS1 (7) и REFS0 (6) устанавливают какой источник опорного напряжения будет выбран:
		0 0 - опорное напряжение на входе AREF (21 ножка)
		0 1 - Vпитания (вход AREF должен быть отключен. или к нему можно подключить фильтрующий конденсатор)
		1 0 - резерв
		1 1 - внутренний ИОН (источник опорного напряжения) 1.1 В (к входу AREF можно подключить фильтрующий конденсатор)
	Бит ADLAR (5) регистра ADMUX позволяет выравнивать результат преобразования по левому краю при записи в него 1.
	Биты MUX3 - MUX0 (3 - 0) - управляют мультиплексором:
		0 0 0 0 - вход ADC0 (23 ножка)
		0 0 0 1 - вход ADC1 (24 ножка)
		0 0 1 0 - вход ADC2 (25 ножка)
		0 0 1 1 - вход ADC3 (26 ножка)
		0 1 0 0 - вход ADC4 (27 ножка)
		0 1 0 1 - вход ADC5 (28 ножка)
		0 1 1 0 - резерв
		0 1 1 1 - резерв
		1 0 0 0 - датчик температуры
		1 0 0 1 - резерв
		1 0 1 0 - резерв
		1 0 1 1 - резерв
		1 1 0 0 - резерв
		1 1 0 1 - резерв
		1 1 1 0 - 1.1 В
		1 1 1 1 - 0 В (земля) */
	ADCSRA = (1<<ADEN)|(1<<ADPS1)|(0<<ADATE)|(0<<ADIF)|(0<<ADIE)|(0<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
	/* Бит ADEN (7) регистра ADCSRA включает или выключает АЦП (1-включен).
	Бит ADSC (6) регистра ADCSRA запускает преобразование если в него записать 1 (для многоразового режима запуск первого преобразования).
	Бит ADATE (5) регистра ADCSRA позволяет запускать преобразование по прерыванию от переферийных устройств микроконтроллера если установить в 1.
	Бит ADIF (4) регистра ADCSRA - флаг прерывания от АЦП.
	Бит ADIE (3) регистра ADCSRA - разрешает прерывания от АЦП если установлен в 1.
	Биты ADPS2 - ADPS0 (2 - 0) регистра ADCSRA выбирают режим работы предделителя тактовой частоты:
		0 0 0 - CLK/2
		0 0 1 - CLK/2
		0 1 0 - CLK/4
		0 1 1 - CLK/8
		1 0 0 - CLK/16
		1 0 1 - CLK/32
		1 1 0 - CLK/64
		1 1 1 - CLK/128	*/
	ADCSRB = (0<<ACME)|(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0);
	/* Бит ACME (6) регистра ADCSRB позволяет использовать мультиплексор АЦП в качестве входов аналогового компаратора при установке 1 ( при этом АЦП должен быть выключен).
	Биты ADTS2 - ADTS0 (2 - 0) регистра ADCSRB выбирают источник сигнала по которому будет начинаться преобразование АЦП:
		0 0 0 - непрерывное преобразование
		0 0 1 - прерывание от аналогового компаратора
		0 1 0 - внешнее прерывание INT0
		0 1 1 - прерывание по совпадению таймера/счетчика T0 с A
		1 0 0 - прерывание по переполнению таймера/счетчика T0
		1 0 1 - прерывание по совпадению таймера/счетчика T1 с B
		1 1 0 - прерывание по переполнению таймера/счетчика T1
		1 1 1 - прерывание по захвату таймера/счетчика T1 */
}

/*******************************************
 * Функция		: измерение уровня сигнала
 * Аргументы	: номер вывода ADCx
 * Ответ		: уровень сигнала
 *******************************************/
unsigned int ADC_read(unsigned char in) {
	ADMUX &=~ (1<<MUX3)|(1<<MUX2)|(1<<MUX1)|(1<<MUX0);
	ADMUX |= (in & 0x0F);
	
	ADCSRA |= (1 << ADSC);
	while (!(ADCSRA & (1 << ADIF)));
	
	return (ADCL + (ADCH << 8));
}

#endif